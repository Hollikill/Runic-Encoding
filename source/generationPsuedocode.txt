generation parameters
[..] variable
?.. toggle

a point weight
b hollow points
c line weight
d intersection types
    d1 degree of difference
e intersection weights

/**********************************************************/

symbolfrom(assemblyparts) {
    vec2 size = getboundingboxsize(assemblyparts)
    Symbol symbol = new Symbol(size);
    for item : assemblyparts {
        Stroke* stroke = symbol.addStroke()
        for point : item.part.points {
            stroke.addpoint(point)
        }
    }
}

vec2 getboundingboxsize(assemblyparts) {
    getmaxx(assemblyparts)
    getminx(assemblyparts)
    getmaxy(assemblyparts)
    getminy(assemblyparts)
    return {maxx-minx, maxy-miny}
}

// four functions at once: [../..] blocks collapse based on function name
int get[min/max][x/y](assemblyparts) {
    int [min/max][x/y] = 0;
    for item : assemblyparts {
        for point : item.part.points {
            if point.[x/y] [min:</max:>] [min/max][x/y] {
                [min/max][x/y] = point.[x/y]
            }
        }
    }
    return [min/max][x/y]
}

/**********************************************************/

struct ref {
    part one;
    part two;
    bool gap; // false for intersec, true for point of reference
}

enum DIRECTION {
    UP;
    UPLEFT;
    LEFT;
    DOWNLEFT;
    DOWN;
    DOWNRIGHT;
    RIGHT;
    UPRIGHT;
}

struct part {
    int type; // using enum PART_TYPE
    vector<vec2> points;
}

enum PART_TYPE {
    line,
    point,
    point_hollow
}

/**********************************************************/

/* GENERATE BAG */

// generate parts

arr<part> parts ..

parts push points rand([a])
    - standard
    ?b circular
parts push lines rand([c])
    - 45deg variations 

/**********************************************************/

// generate a number of intersections

enum SELECTION_CRITERIA_TYPE {
    none,
    filtered,
    lowangle
}

class GenericIntersection {
    partID one;
    partID two;

    int selectionCriteriaType; // using enum SELECTION_CRITERIA_TYPE
    vector<int> validComponents; // using enum PART_TYPE
}

// 1: assign intersections to parts that fit criteria
// 2: ensure no loops exist in the node-graph of intersections, or redo 1
// 3: assemble each isolated island using random valid configurations
// this should be done step-by-step, only 2 parts at a time.
// This begins from one parts, proceeds to all the connected parts one-by-one, and after all of them recursively does the same for each of those
// 3a: valid criteria:
//      - parts should not overlap
//      - parts should not genertate an intersection
// 3b: attachment method: the origin of a part will be randomly assigned to a point of the existing configuration
//      OR a possible midpoint, in which case the length of the line is extended by one, and all parts connected further than that point are moved in the direction of the source part by one
// TODO rest later


TODO: Bezier curve line segments; more complex shape segments that can be extended in <x> places using predefined simple extension methods (like a line)

/**********************************************************/

/* ENSURE CONNECTIONS */

arr<ref> intersecs ..

//  generate intersections

intersecCount = unknownformula([e])
    ?d
    - no more than [d1]deg difference
    - must be perpendicular to each other
for intersecCount
    part line1
    part line2
    do while (intersecs.has(line1) || intersecs.has(line2)) {
        line1, line2 = parts[rand]
        if attempts > 10 regen from #generatebag
    }
    intersecs.add(ref{line1, line2, false})

//
// Intersecs & refs are same type of object, just with a different offset
// Points are only added in ref step
// Points return same endp from intersecs.otherendp
// Each endp is marked with an invalid dir enum
//

/* ASSEMBLY STEPS */

// assemble based on intersec and referencepoints

struct assemblypart {
    part part;
    bool isadded = false;
    vec2 adjustment = {0,0};
}

arr<assemblypart> assemblyparts ..

for item : parts
    assemblyparts.add(assemblypart{item, false, {0,0}})

int firstpartID = rand % assemblyparts.size

assemblyparts[firstpartID].isadded = true;

while(not assemblyparts.fullyadded()) {
    for item : assemblyparts
        if item.isadded = false {
            if intersecs.exists(assemblyparts.addedtovector(), item.part.ID) {
                item.adjustment = itersec.getotherpart(item.part.ID).points.at(rand);
            }
            else {
                item.adjustment = assemblyparts.addedtovector().at(rand).part.points.at(rand)
            }
        }
}

TODO: figure out how the hell to have a part in multiple intersections
TODO: make sure parts don't overlap. Could be here, could just be an end check