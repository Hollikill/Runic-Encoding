generation parameters
[..] variable
?.. toggle

a point weight
b hollow points
c line weight
d intersection types
    d1 degree of difference
e intersection weights

/**********************************************************/

symbolfrom(assemblyparts) {
    vec2 size = getboundingboxsize(assemblyparts)
    Symbol symbol = new Symbol(size);
    for item : assemblyparts {
        Stroke* stroke = symbol.addStroke()
        for point : item.part.points {
            stroke.addpoint(point)
        }
    }
}

vec2 getboundingboxsize(assemblyparts) {
    getmaxx(assemblyparts)
    getminx(assemblyparts)
    getmaxy(assemblyparts)
    getminy(assemblyparts)
    return {maxx-minx, maxy-miny}
}

// four functions at once: [../..] blocks collapse based on function name
int get[min/max][x/y](assemblyparts) {
    int [min/max][x/y] = 0;
    for item : assemblyparts {
        for point : item.part.points {
            if point.[x/y] [min:</max:>] [min/max][x/y] {
                [min/max][x/y] = point.[x/y]
            }
        }
    }
    return [min/max][x/y]
}

/**********************************************************/

struct ref {
    part one;
    part two;
    bool gap; // false for intersec, true for point of reference
}

enum DIRECTION {
    UP;
    UPLEFT;
    LEFT;
    DOWNLEFT;
    DOWN;
    DOWNRIGHT;
    RIGHT;
    UPRIGHT;
}

struct part {
    string type; // line, point, point_hollow
    vector<vec2> points;
}

/**********************************************************/

/* GENERATE BAG */

// generate parts

arr<part> parts ..

parts push points rand([a])
    - standard
    ?b circular
parts push lines rand([c])
    - 45deg variations 

/* ENSURE CONNECTIONS */

arr<ref> intersecs ..

//  generate intersections

intersecCount = unknownformula([e])
    ?d
    - no more than [d1]deg difference
    - must be perpendicular to each other
for intersecCount
    part line1
    part line2
    do while (intersecs.has(line1) || intersecs.has(line2)) {
        line1, line2 = parts[rand]
        if attempts > 10 regen from #generatebag
    }
    intersecs.add(ref{line1, line2, false})

//
// Intersecs & refs are same type of object, just with a different offset
// Points are only added in ref step
// Points return same endp from intersecs.otherendp
// Each endp is marked with an invalid dir enum
//

/* ASSEMBLY STEPS */

// assemble based on intersec and referencepoints

struct assemblypart {
    part part;
    bool isadded = false;
    vec2 adjustment = {0,0};
}

arr<assemblypart> assemblyparts ..

for item : parts
    assemblyparts.add(assemblypart{item, false, {0,0}})

int firstpartID = rand % assemblyparts.size

assemblyparts[firstpartID].isadded = true;

while(not assemblyparts.fullyadded()) {
    for item : assemblyparts
        if item.isadded = false {
            if intersecs.exists(assemblyparts.addedtovector(), item.part.ID) {
                item.adjustment = itersec.getotherpart(item.part.ID).points.at(rand);
            }
            else {
                item.adjustment = assemblyparts.addedtovector().at(rand).part.points.at(rand)
            }
        }
}

TODO: figure out how the hell to have a part in multiple intersections
TODO: make sure parts don't overlap. Could be here, could just be an end check